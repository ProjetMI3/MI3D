#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define NB_CARTES_MAX 151        // Nombre maximal de cartes dans la pioche (150 cartes au max)
#define NB_CARTES_JOUEUR 6      // Nombre de cartes par joueur (on devrait demander aux joueurs)
#define NB_JOUEURS_MAX 9        // Nombre maximum de joueurs autorisés (8 joueurs au max)


// Structure d'une carte
typedef struct {
	int valeur;     // Valeur de la carte (de -2 à +12)
	int visible;    // 0 = face cachée, 1 = visible
} Carte;

// Structure d'une pile de cartes (pioche ou défausse)
typedef struct {
	Carte cartes[NB_CARTES_MAX]; // Tableau de cartes
	int top;                  // Nombre de cartes actuellement dans la pile
} Pile;

// Structure d'un joueur
typedef struct {
	char *nom;               // Nom du joueur (pointeur pour allouer la taille nécessaire)
	Carte main[NB_CARTES_JOUEUR];  // Cartes personnelles du joueur
	Pile defausse;              // Pile de défausse du joueur
} Joueur;

// Créer une carte avec une valeur et une visibilité donnée
Carte creer_carte(int valeur, int visible) {
	Carte c;
	c.valeur = valeur;
	c.visible = visible;
	return c;
}

// Mélanger les cartes dans une pile avec l'algorithme de Fisher-Yates
void melanger_pile(Pile* pile) {
	for (int i = 0; i < pile->top; i++) {
		int j = rand() % pile->top;
		Carte temp = pile->cartes[i];
		pile->cartes[i] = pile->cartes[j];
		pile->cartes[j] = temp;
 //algo de Fisher-Yates
  for (int i = pile->top - 1; i > 0; i--) {
        int j = rand() % (i + 1); // Générer un index aléatoire entre 0 et i
        // Échanger les cartes aux positions i et j
        Pile temp->cartes[i] = pile->cartes[i];
        pile->cartes[i] = pile->cartes[j];
        pile[j] = temp->cartes[i];
	}
}

// Initialiser la pioche centrale avec toutes les cartes du jeu 
void initialiser_pioche(Pile* pioche) {
    pioche->top = 0; // On commence avec une pile vide

    // Tableau pour les quantités spéciales de -2, -1 et 0
    int quantites[3] = {5, 10, 15};  // index 0 = -2, index 1 = -1, index 2 = 0

    // On parcourt toutes les valeurs possibles de cartes
    for (int valeur = -2; valeur <= 12; valeur++) {
        int nombre;

        // Si la valeur est -2, -1 ou 0, on la prend dans le tableau quantites
        if (valeur == -2)
            nombre = quantites[0];
        else if (valeur == -1)
            nombre = quantites[1];
        else if (valeur == 0)
            nombre = quantites[2];
        else
            nombre = 10; // Par défaut, il y a 10 cartes de chaque valeur positive

        // On ajoute 'nombre' cartes de cette valeur dans la pioche
        for (int i = 0; i < nombre; i++) {
            Carte nouvelle = creer_carte(valeur, 0); // 0 = face cachée
            pioche->cartes[pioche->top] = nouvelle;
            pioche->top++;
        }
    }
       // Initialiser la pioche centrale mais ça m'a l'air + simple comme ça 
      pioche->top = 0; // Initialisation avec une pioche vide
      pioche->cartes[NB_CARTES_MAX].visile = {0}; // Face cachée car la pioche n'est jamais visible
    // Ajouter 5 cartes de valeur -2
    for (int i = 0; i < 5; i++) {
        pioche[top++]->cartes.valeur = -2;
    }

    // Ajouter 10 cartes de valeur -1
    for (int i = 0; i < 10; i++) {
        pioche[top++]->cartes.valeur = -1;
    }

    // Ajouter 15 cartes de valeur 0
    for (int i = 0; i < 15; i++) {
        pioche[top++]->cartes.valeur = 0;
    }

    // Ajouter 10 cartes pour chaque valeur de 1 à 12
    for (int val = 1; val <= 12; val++) {
        for (int i = 0; i < 10; i++) {
            pioche[index++]->cartes.valeur = val;
        }
    }
}

    melanger_pile(pioche); // Mélange final de la pioche
}

// Afficher une carte
void afficher_carte(Carte c) {
	if (c.visible)
		printf("[ %2d ]", c.valeur); // Affiche la carte si elle est visible
	else
		printf("[ ?? ]"); // Met des ?? si elle est face cacher
}

// Afficher la main du joueur
void afficher_main(Joueur joueur) {
  int nb_cartes_joueur;
  printf("Saisir le nombre de cartes personnelles pour chaque joueur (minimum une) :");
  scanf("%d",&nb_cartes_joueur);
  while(scanf("%d",&nb_cartes_joueur)!=1){  //vérifier que c'est bien un entier
    fprintf(stderr,"Erreur dans la saisie, le terme doit être un entier (strictement positif).\nRessaisissez :\n");  
    scanf("%d",&nb_cartes_joueur);
  }
  while(nb_cartes_joueurs < 1 ){
    fprintf(stderr,"Erreur dans la saisie, le terme doit être un entier strictement positif.\nRessaisissez :\n");  
    scanf("%d",&nb_cartes_joueur);
  }
	for (int i = 0; i < NB_CARTES_JOUEUR; i++) { // Parcourt toutes les cartes de la main du joueur
		printf("%d: ", i); // Affiche l'indice de la carte
		afficher_carte(joueur.main[i]); // Affiche la carte correspondante
		printf("  "); // Espace entre les cartes
	}
	printf("\n"); // Retour à la ligne après avoir affiché toutes les cartes
}

int main() {
	srand(time(NULL)); 

	int nb_joueurs;
	printf("Bienvenue sur CardYard (version française) !\n");
	printf("Combien de joueurs ? (2 à 8) : %d ", NB_JOUEURS_MAX);
	scanf("%d", &nb_joueurs);

	while (nb_joueurs < 2 || nb_joueurs > NB_JOUEURS_MAX) {
		printf("Nombre invalide. Ressaisissez le nombre de joueurs :\n");
    scanf("%d",&nb_joueurs);
	}

	Joueur joueurs[NB_JOUEURS_MAX];
	Pile pioche;
  initialiser_pioche(&pioche);
  int i;
  
// Il faudrait allouer la taille nécessaire pour les noms


	// Initialisation des joueurs
	for (i = 0; i < nb_joueurs; i++) {
		char nom[30];
		printf("Nom du joueur %d : ", i + 1);
		scanf("%s", nom);
		initialiser_joueur(&joueurs[i], nom, &pioche);
	}
	
	// Affiche l’état de jeu du joueur actif à son tour
	printf("\n--- Tour de %s ---\n", joueur->nom);
	afficher_main(*joueur); // Affiche toutes les cartes du joueur 

	if (joueur->defausse.top > 0) {
    	printf("Carte sur la défausse : ");
    	afficher_carte(joueur->defausse.cartes[joueur->defausse.top - 1]); // Affiche la carte visible sur la défausse
    	printf("\n");
	}

	int partie_finie = 0;
	int joueur_fin = -1;
  return 0;
}
